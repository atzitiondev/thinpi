#if 0
	shc Version 3.9.6, Generic Shell Script Compiler
	GNU GPL Version 3 Md Jahidul Hamid <jahidulhamid@yahoo.com>

	shc -f src/thinpi/tpupdate/tpupdate 
#endif

static  char data [] = 
#define      pswd_z	256
#define      pswd	((&data[48]))
	"\173\311\006\002\122\051\173\214\274\005\150\162\171\173\357\107"
	"\304\162\171\140\173\353\166\125\171\233\255\001\236\152\201\032"
	"\064\207\034\206\261\230\023\155\235\174\337\027\367\317\137\274"
	"\042\220\062\320\346\336\313\051\244\257\130\337\074\221\136\101"
	"\207\211\121\007\332\206\020\205\071\206\272\246\220\154\356\262"
	"\375\040\203\343\376\116\014\243\376\145\203\073\366\341\175\175"
	"\152\316\205\105\125\226\312\216\034\204\065\254\360\043\137\355"
	"\104\342\321\103\061\335\346\057\103\151\152\071\112\350\267\265"
	"\266\075\372\014\324\304\232\360\111\317\235\072\363\374\047\067"
	"\337\371\172\020\326\141\100\031\312\253\123\025\223\013\312\112"
	"\110\304\126\034\210\360\015\321\300\253\014\264\250\064\354\207"
	"\055\146\230\003\310\330\035\222\203\161\247\027\174\162\141\305"
	"\066\267\341\277\250\357\221\150\232\235\035\102\321\011\312\376"
	"\160\142\002\070\072\040\313\276\221\163\325\015\345\066\322\034"
	"\356\264\333\226\243\155\377\076\013\034\200\334\046\112\333\226"
	"\255\335\316\347\375\232\246\217\015\173\234\363\262\157\017\240"
	"\043\353\067\307\130\066\005\143\123\206\100\171\320\033\017\175"
	"\371\336\145\367\170\014\206\206\210\043\171\072\222\211\333\265"
	"\164\022\175\315\111\202\061\234\011\162\025\331\216\044\127\207"
	"\101\330\035\275\303\223\022\074\056\277\076\315\052\277\347\137"
	"\106\004\346\370\235\371\145\072\166\105\122\155\024\261\052\126"
#define      chk1_z	22
#define      chk1	((&data[337]))
	"\114\067\116\074\237\377\265\126\353\322\102\215\171\325\153\225"
	"\013\047\264\050\356\331\101"
#define      text_z	826
#define      text	((&data[389]))
	"\012\345\307\327\017\206\277\156\315\303\125\305\140\116\053\233"
	"\304\160\355\062\205\237\134\334\050\244\357\165\177\025\244\254"
	"\012\051\012\261\326\255\161\257\022\035\300\365\177\305\262\111"
	"\227\204\025\144\105\165\322\210\267\030\006\110\227\007\226\052"
	"\271\044\172\120\352\072\261\375\065\173\111\100\302\347\307\247"
	"\315\205\021\030\162\242\227\057\360\247\070\053\215\121\172\231"
	"\111\351\223\225\010\064\005\002\223\345\204\341\320\024\375\333"
	"\207\313\227\316\145\062\022\265\345\102\000\035\211\145\154\232"
	"\273\127\310\241\270\037\107\032\156\002\247\146\155\010\270\041"
	"\040\353\242\025\221\240\075\060\241\004\356\317\342\267\003\347"
	"\146\133\377\156\266\170\331\200\270\007\117\270\154\240\073\161"
	"\033\044\052\325\371\141\235\054\046\035\104\373\361\206\251\042"
	"\233\003\303\100\034\107\021\117\326\377\272\005\053\105\344\162"
	"\367\026\031\335\060\005\200\152\061\253\267\107\276\344\222\133"
	"\333\341\013\132\303\247\034\173\362\067\327\225\035\217\320\264"
	"\343\167\217\116\326\140\325\104\054\217\253\355\345\254\157\332"
	"\171\364\075\274\304\076\125\173\141\141\126\372\147\115\213\136"
	"\200\357\245\322\172\057\006\341\025\147\141\024\332\162\274\132"
	"\302\330\067\154\042\234\124\021\265\030\044\270\226\172\076\243"
	"\126\175\153\233\122\224\032\004\112\067\252\062\140\207\145\300"
	"\205\010\312\205\174\330\062\003\276\010\175\336\153\336\267\370"
	"\221\247\321\021\043\354\276\233\152\357\312\251\104\024\246\043"
	"\110\247\004\303\355\022\210\357\374\117\040\011\044\224\073\050"
	"\241\301\333\044\055\373\001\031\355\001\305\203\343\074\070\047"
	"\125\175\370\254\140\010\031\254\207\153\246\127\255\344\065\263"
	"\246\377\245\150\050\005\161\304\271\141\262\131\131\327\142\354"
	"\127\023\357\372\113\343\224\272\361\335\044\230\202\262\054\321"
	"\125\262\021\102\327\010\034\143\157\342\034\305\062\143\325\107"
	"\306\250\333\022\330\367\175\056\147\240\161\372\275\324\207\244"
	"\354\220\010\251\162\361\367\326\230\033\062\065\162\113\043\256"
	"\267\336\047\032\174\377\003\227\142\000\043\065\133\307\307\315"
	"\125\030\362\246\340\156\002\223\115\205\300\010\225\363\136\042"
	"\234\055\202\042\100\321\064\053\373\000\215\163\134\161\020\361"
	"\327\075\272\111\150\121\102\154\164\053\313\007\170\261\110\071"
	"\230\010\324\113\036\064\117\164\113\225\174\325\052\373\376\057"
	"\274\365\332\210\051\224\200\102\261\135\206\064\163\360\324\002"
	"\070\145\036\024\071\224\147\345\075\035\136\203\071\157\213\174"
	"\221\273\272\214\177\264\151\217\242\246\310\056\023\043\232\056"
	"\154\222\305\134\151\245\040\205\030\171\173\031\065\236\317\374"
	"\151\233\373\123\023\363\154\106\063\203\201\145\371\376\247\111"
	"\120\154\151\032\136\017\261\112\175\303\216\160\037\061\227\271"
	"\361\141\344\350\075\377\077\321\106\216\074\131\260\230\244\250"
	"\266\002\247\203\036\345\157\302\252\204\375\123\151\244\200\063"
	"\006\153\312\017\257\363\055\103\151\304\123\366\230\254\012\341"
	"\373\273\000\211\224\124\027\316\302\310\322\351\341\325\300\265"
	"\341\313\361\175\116\232\155\350\050\207\111\154\366\160\145\274"
	"\063\025\240\224\100\010\014\253\031\275\216\205\250\365\354\326"
	"\270\142\352\331\354\336\154\006\254\343\177\116\144\100\175\311"
	"\100\326\216\362\272\316\040\150\037\301\000\035\353\376\030\164"
	"\324\114\367\010\350\365\027\134\312\052\173\023\122\303\155\145"
	"\003\071\222\016\302\120\075\310\334\216\074\004\047\360\073\261"
	"\345\116\143\124\363\217\037\200\311\362\325\114\356\175\173\205"
	"\167\333\075\241\006\307\264\350\050\001\114\320\120\275\372\041"
	"\341\262\264\017\115\320\370\213\376\211\372\306\141\012\114\040"
	"\171\032\344\316\337\105\035\013\340\342\173\316\025\001\155\161"
	"\335\226\026\315\013\226\343\012\040\336\320\201\351\035\242\142"
	"\067\207\061\027\314\117\042\255\061\236\174\106\237\352\270\175"
	"\200\317\113\214\145\056\227\205\014\147\007\366\205\251\130\274"
	"\061\212\324\376\331\366\253\013\224\050\122\064\022\012\262\223"
	"\332\375\040\077\054\267\304\071\037\314\057\244\165\210\141\247"
	"\022\065\245\354\053\120\367"
#define      opts_z	1
#define      opts	((&data[1326]))
	"\236"
#define      chk2_z	19
#define      chk2	((&data[1329]))
	"\247\037\327\124\164\037\022\266\351\001\214\077\122\236\044\064"
	"\062\111\235\005\146\056"
#define      msg2_z	19
#define      msg2	((&data[1350]))
	"\321\251\352\031\236\173\236\130\207\157\266\267\101\316\210\146"
	"\134\011\200\022\367\063"
#define      msg1_z	65
#define      msg1	((&data[1372]))
	"\071\116\067\027\031\355\174\141\211\161\312\066\146\237\076\111"
	"\327\342\304\131\256\107\201\051\260\341\146\331\360\155\246\354"
	"\247\075\107\127\315\254\340\110\327\351\037\337\123\262\252\370"
	"\362\312\050\212\376\106\212\160\300\330\264\373\206\216\123\266"
	"\353\022\273\165\302\034\034\324\121\301\301\174\022\270\075\213"
	"\002\061"
#define      date_z	1
#define      date	((&data[1453]))
	"\114"
#define      shll_z	10
#define      shll	((&data[1455]))
	"\166\302\354\175\042\144\362\225\356\023\346\364"
#define      inlo_z	3
#define      inlo	((&data[1466]))
	"\172\230\366"
#define      xecc_z	15
#define      xecc	((&data[1471]))
	"\222\100\125\252\072\315\175\215\132\365\274\320\123\135\050\076"
	"\151"
#define      rlax_z	1
#define      rlax	((&data[1486]))
	"\053"
#define      tst2_z	19
#define      tst2	((&data[1487]))
	"\103\101\251\033\045\225\010\233\121\054\301\066\010\226\172\074"
	"\210\000\374\172\352\052"
#define      lsto_z	1
#define      lsto	((&data[1509]))
	"\360"
#define      tst1_z	22
#define      tst1	((&data[1513]))
	"\060\375\162\230\356\053\320\255\176\027\043\301\025\012\106\345"
	"\201\321\077\251\306\251\072\126\105\147\204\357"/* End of data[] */;
#define      hide_z	4096
#define DEBUGEXEC	0	/* Define as 1 to debug execvp calls */
#define TRACEABLE	1	/* Define as 1 to enable ptrace the executable */
#define BUSYBOXON	0	/* Define as 1 to enable work with busybox */

/* rtc.c */

#include <sys/stat.h>
#include <sys/types.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

/* 'Alleged RC4' */

static unsigned char stte[256], indx, jndx, kndx;

/*
 * Reset arc4 stte. 
 */
void stte_0(void)
{
	indx = jndx = kndx = 0;
	do {
		stte[indx] = indx;
	} while (++indx);
}

/*
 * Set key. Can be used more than once. 
 */
void key(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		do {
			tmp = stte[indx];
			kndx += tmp;
			kndx += ptr[(int)indx % len];
			stte[indx] = stte[kndx];
			stte[kndx] = tmp;
		} while (++indx);
		ptr += 256;
		len -= 256;
	}
}

/*
 * Crypt data. 
 */
void arc4(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		indx++;
		tmp = stte[indx];
		jndx += tmp;
		stte[indx] = stte[jndx];
		stte[jndx] = tmp;
		tmp += stte[indx];
		*ptr ^= stte[tmp];
		ptr++;
		len--;
	}
}

/* End of ARC4 */

/*
 * Key with file invariants. 
 */
int key_with_file(char * file)
{
	struct stat statf[1];
	struct stat control[1];

	if (stat(file, statf) < 0)
		return -1;

	/* Turn on stable fields */
	memset(control, 0, sizeof(control));
	control->st_ino = statf->st_ino;
	control->st_dev = statf->st_dev;
	control->st_rdev = statf->st_rdev;
	control->st_uid = statf->st_uid;
	control->st_gid = statf->st_gid;
	control->st_size = statf->st_size;
	control->st_mtime = statf->st_mtime;
	control->st_ctime = statf->st_ctime;
	key(control, sizeof(control));
	return 0;
}

#if DEBUGEXEC
void debugexec(char * sh11, int argc, char ** argv)
{
	int i;
	fprintf(stderr, "shll=%s\n", sh11 ? sh11 : "<null>");
	fprintf(stderr, "argc=%d\n", argc);
	if (!argv) {
		fprintf(stderr, "argv=<null>\n");
	} else { 
		for (i = 0; i <= argc ; i++)
			fprintf(stderr, "argv[%d]=%.60s\n", i, argv[i] ? argv[i] : "<null>");
	}
}
#endif /* DEBUGEXEC */

void rmarg(char ** argv, char * arg)
{
	for (; argv && *argv && *argv != arg; argv++);
	for (; argv && *argv; argv++)
		*argv = argv[1];
}

void chkenv_end(void);

int chkenv(int argc)
{
	char buff[512];
	unsigned long mask, m;
	int l, a, c;
	char * string;
	extern char ** environ;

	mask = (unsigned long)getpid();
	stte_0();
	 key(&chkenv, (void*)&chkenv_end - (void*)&chkenv);
	 key(&data, sizeof(data));
	 key(&mask, sizeof(mask));
	arc4(&mask, sizeof(mask));
	sprintf(buff, "x%lx", mask);
	string = getenv(buff);
#if DEBUGEXEC
	fprintf(stderr, "getenv(%s)=%s\n", buff, string ? string : "<null>");
#endif
	l = strlen(buff);
	if (!string) {
		/* 1st */
		sprintf(&buff[l], "=%lu %d", mask, argc);
		putenv(strdup(buff));
		return 0;
	}
	c = sscanf(string, "%lu %d%c", &m, &a, buff);
	if (c == 2 && m == mask) {
		/* 3rd */
		rmarg(environ, &string[-l - 1]);
		return 1 + (argc - a);
	}
	return -1;
}

void chkenv_end(void){}

#if !TRACEABLE

#define _LINUX_SOURCE_COMPAT
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

#if !defined(PTRACE_ATTACH) && defined(PT_ATTACH)
#	define PTRACE_ATTACH	PT_ATTACH
#endif
void untraceable(char * argv0)
{
	char proc[80];
	int pid, mine;

	switch(pid = fork()) {
	case  0:
		pid = getppid();
		/* For problematic SunOS ptrace */
#if defined(__FreeBSD__)
		sprintf(proc, "/proc/%d/mem", (int)pid);
#else
		sprintf(proc, "/proc/%d/as",  (int)pid);
#endif
		close(0);
		mine = !open(proc, O_RDWR|O_EXCL);
		if (!mine && errno != EBUSY)
			mine = !ptrace(PTRACE_ATTACH, pid, 0, 0);
		if (mine) {
			kill(pid, SIGCONT);
		} else {
			perror(argv0);
			kill(pid, SIGKILL);
		}
		_exit(mine);
	case -1:
		break;
	default:
		if (pid == waitpid(pid, 0, 0))
			return;
	}
	perror(argv0);
	_exit(1);
}
#endif /* !TRACEABLE */

char * xsh(int argc, char ** argv)
{
	char * scrpt;
	int ret, i, j;
	char ** varg;
	char * me = argv[0];
	if (me == NULL) { me = getenv("_"); }
	if (me == 0) { fprintf(stderr, "E: neither argv[0] nor $_ works."); exit(1); }

	ret = chkenv(argc);
	stte_0();
	 key(pswd, pswd_z);
	arc4(msg1, msg1_z);
	arc4(date, date_z);
	if (date[0] && (atoll(date)<time(NULL)))
		return msg1;
	arc4(shll, shll_z);
	arc4(inlo, inlo_z);
	arc4(xecc, xecc_z);
	arc4(lsto, lsto_z);
	arc4(tst1, tst1_z);
	 key(tst1, tst1_z);
	arc4(chk1, chk1_z);
	if ((chk1_z != tst1_z) || memcmp(tst1, chk1, tst1_z))
		return tst1;
	arc4(msg2, msg2_z);
	if (ret < 0)
		return msg2;
	varg = (char **)calloc(argc + 10, sizeof(char *));
	if (!varg)
		return 0;
	if (ret) {
		arc4(rlax, rlax_z);
		if (!rlax[0] && key_with_file(shll))
			return shll;
		arc4(opts, opts_z);
		arc4(text, text_z);
		arc4(tst2, tst2_z);
		 key(tst2, tst2_z);
		arc4(chk2, chk2_z);
		if ((chk2_z != tst2_z) || memcmp(tst2, chk2, tst2_z))
			return tst2;
		/* Prepend hide_z spaces to script text to hide it. */
		scrpt = malloc(hide_z + text_z);
		if (!scrpt)
			return 0;
		memset(scrpt, (int) ' ', hide_z);
		memcpy(&scrpt[hide_z], text, text_z);
	} else {			/* Reexecute */
		if (*xecc) {
			scrpt = malloc(512);
			if (!scrpt)
				return 0;
			sprintf(scrpt, xecc, me);
		} else {
			scrpt = me;
		}
	}
	j = 0;
#if BUSYBOXON
	varg[j++] = "busybox";
	varg[j++] = "sh";
#else
	varg[j++] = argv[0];		/* My own name at execution */
#endif
	if (ret && *opts)
		varg[j++] = opts;	/* Options on 1st line of code */
	if (*inlo)
		varg[j++] = inlo;	/* Option introducing inline code */
	varg[j++] = scrpt;		/* The script itself */
	if (*lsto)
		varg[j++] = lsto;	/* Option meaning last option */
	i = (ret > 1) ? ret : 0;	/* Args numbering correction */
	while (i < argc)
		varg[j++] = argv[i++];	/* Main run-time arguments */
	varg[j] = 0;			/* NULL terminated array */
#if DEBUGEXEC
	debugexec(shll, j, varg);
#endif
	execvp(shll, varg);
	return shll;
}

int main(int argc, char ** argv)
{
#if DEBUGEXEC
	debugexec("main", argc, argv);
#endif
#if !TRACEABLE
	untraceable(argv[0]);
#endif
	argv[1] = xsh(argc, argv);
	fprintf(stderr, "%s%s%s: %s\n", argv[0],
		errno ? ": " : "",
		errno ? strerror(errno) : "",
		argv[1] ? argv[1] : "<null>"
	);
	return 1;
}
